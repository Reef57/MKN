%Выводим переменные в глобальную область видимости, чтоб не подавать их в
%функции
global n;
global t;

%Эти значения даны в условии контрольной для каждого варианта свои
n = 4;
k = 2;
m = 2;

%Отображение 12 знаков после запятой
format long;

%Воспринимать х как символ, а не переменную
syms x;

%Выделить память под массив из 5 значений функции и пока заполнить их
%нулями
y = zeros(1, 5);
%Выделить память под n + 1 точку аргумента функции y = y(t), выделяем
%память для t. Заполняем его равномерно интервалом от 0.1 до 0.6
t = linspace(0.1, 0.6, n + 1);

%Считаем шаг сетки
h = t(2) - t(1);

%Записываем свою функцию в F
F(x) = x^3 - cos(2 * x);

%Записываем вторую производную от F в f
f(x) = diff(F(x), 2);

%Заоплняем массив значений функции соответственно для каждой точки входного
%интервала. Например t(0) = 0.1 => y(0) = F(0.1)
for i=1:n+1
    y(i) = t(i)^3 - cos(2 * t(i));
end

%Записали полином Лагранжа в (очень) явном виде
P(x) = y(1)*((x-t(2))*(x-t(3))*(x-t(4))*(x-t(5))) / (((1-2)*h)*((1-3)*h)*((1-4)*h)*((1-5)*h)) + ...
    y(2)*((x-t(1))*(x-t(3))*(x-t(4))*(x-t(5))) / (((2-1)*h)*((2-3)*h)*((2-4)*h)*((2-5)*h)) + ...
    y(3)*((x-t(1))*(x-t(2))*(x-t(4))*(x-t(5))) / (((3-1)*h)*((3-2)*h)*((3-4)*h)*((3-5)*h)) + ...
    y(4)*((x-t(1))*(x-t(2))*(x-t(3))*(x-t(5))) / (((4-1)*h)*((4-2)*h)*((4-3)*h)*((4-5)*h)) + ...
    y(5)*((x-t(1))*(x-t(2))*(x-t(3))*(x-t(4))) / (((5-1)*h)*((5-2)*h)*((5-3)*h)*((5-4)*h));

%Берём от него вторую производную
L(x) = diff(P(x), 2);

%Считаем значения во второй точке входного интервала сначала от истинной
%функции, а потом от нашей. Так как они использовали символы, то нужно
%принудительно вызвать команду double(), чтобы ответ был не в символьном
%виде, а число
double(f(t(2)));
double(L(t(2)));

%Абсолютная погрешность
abs_dif = abs(double(L(t(2))-f(t(2))));

%Выделяем память под массив размером n + 1 и заполняем его нулями. Он
%нужен, чтоб считать теоретичскую ошибку в каждой из n + 1 точек
R = zeros(1, n+1);
%Считаем факториал заранее, чтоб не делать это в цикле
fact = factorial(n + 1);

%Считаем теоретическую ошибку для каждой точки
for i = 1:n+1
   R(i) = abs((y(i)/fact) * omega(i));
end

%Находим R_min и R_max
Rmin = min(R);
Rmax = max(R);

%Проверяем, корректен ли наш результат. Если это условие истинно (так как в
%конце нет ';', то результат будет выведен в консоль)
abs_dif > Rmin && abs_dif < Rmax

%Вспомогательная функция, чтоб считать ошибку
function res = omega(x)
%Объявляем, что будем использвать глобальные переменные n и t
    global n;
    global t;
%Начальное значение
    res = 1;
%Формула. Здесь x - символ, т.е., в конце res - это полином, зависящий от x
    for i = 1:n+1
        res = res * (x - t(i));
    end
end

