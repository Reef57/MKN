%Включить отображение 12 знаков после запятой
format long e

%Задаём функцию
f = @(x) x.^3 - cos(2 .* x);

%Делаем переменную t "символьной". Типа если будет написано 'a = t-5', то
%матлаб не будет пытаться подставить туда значение t, а так и оставит
%запись
syms t

%Функция F - будет считать 4 производную от нашей функции
F(t) = diff(abs(t^3 - cos(2 * t)), 4);

%F1 - первую
F1(t) = diff(abs(t^3 - cos(2 * t)));

%F2 - вторую
F2(t) = diff(abs(t^3 - cos(2 * t)), 2);

%Запоминаем точное значение интеграла
Istar = integral(f, 0.1, 0.6);
%Выводим на экран
fprintf("I* = %s\n", Istar);

% for j = 4
%     n = 2^j;
%     
%     Разбиваем наш отрезок на n точек
%     x = linspace(0.1, 0.6, n);
%     Записываем в массив y значения функции в этих точках
%     y = f(x);
%     Записываем значения 4-й производной в этих же точках
%     Y = F(x);
%     
%     Выводим на экран количество точек
%     fprintf("n = %d\n", n);
%     
%     Считаем интеграл методом Симпсона и выводим на экран
%     I = Simpson(x, y);
%     fprintf("I = %s\n", I);
%     
%     Считаем абсолютную ошибку
%     DeltaI = abs(Istar - I);
%     fprintf("Delta I = %s\n", DeltaI);
%     
%     Считаем относительную ошибку
%     deltai = DeltaI / abs(Istar) * 100;
%     fprintf("delta i = %s\n", deltai);
%     
%     Считаем теоретическую ошибку
%     R = double((max(Y) * 0.5^5) / (180 * n^4));
%     fprintf("R = %s\n", R);
% end

%Разбиваем входной интервал на 10к точек
x = linspace(0.1, 0.6, 10000);
y = f(x);
Y = F(x);
%Записываем в массив значения первой производной
Y1 = F1(x);
%Записываем значения второй производной
Y2 = F2(x);

%Считаем интеграл методом левых прямоугольников
I1 = left(x, y);
DeltaI1 = abs(Istar - I1);
deltaI1 = DeltaI1 / abs(Istar);
R1 = double(max(Y1) / 2 * 0.5 * (x(2) - x(1)));

%Метод правых прямоугольников
I2 = right(x, y);
DeltaI2 = abs(Istar - I2);
deltaI2 = DeltaI2 / abs(Istar);

%Метод центральных прямоугольников
I3 = center(x, y);
DeltaI3 = abs(Istar - I3);
deltaI3 = DeltaI3 / abs(Istar);
R3 = double((max(Y2) * 0.5^3) / 24 );

%Метод трапеций
I4 = trap(x, y);
I44 = trapz(x, y);
DeltaI4 = abs(Istar - I4);
deltaI4 = DeltaI4 / abs(Istar);
R4 = double((max(Y2) * 0.5^3) / (12 * 100000000))

%Метод Симпсона
I5 = Simpson(x, y);
DeltaI5 = abs(Istar - I5);
deltaI5 = DeltaI5 / abs(Istar);
R = double((max(Y) * 0.5^5) / (180 * n^4));

function I = Simpson(x, y)
%   n - количество пар точек, которые подали на вход
    n = fix(length(x) / 2);

%   Начальное значение интеграла - значение функции в самой левой точке
    I = y(1);
%   Прибавляем значения функции в нечётных точках * 4
    for i = 2 : n
        I = I + y(2 * i - 1) * 4;
    end
    
%   Прибавляем значения функции в чётных точках * 2
    for i = 2 : n - 1
        I = I + y(2 * i) * 2;
    end
    
%   Прибавляем значение функции в последней точке
    I = I + y(2 * n);
    
%   Полученный результат умножаем на шаг сетки, поделённый на 3
    I = I * (x(2) - x(1)) / 3;
end

function I = left(x, y)
%   Количество точек считаем
    n = length(x);
%   Считаем шаг сетки
    h = x(2) - x(1);
    
%   Начальное значение интеграла = 0
    I = 0;
    
%   Умножаем h на значения функции во всех левых точках
    for i = 1 : n - 1
        I = I + h * y(i);
    end
end

function I = right(x, y)
    n = length(x);
    h = x(2) - x(1);
    
    I = 0;
    
%   Умножаем h на значения функции во всех правых точках
    for i = 2 : n
        I = I + h * y(i);
    end
end

function I = center(x, y)
    n = length(x);
%   Считаем шаг сетки * 2
    h = x(3) - x(1);
    
    I = 0;
    
%   Умножаем h на значения функции во всех средних точках
    for i = 2 : n / 2
        I = I + y(2 * i - 2) * h;
    end
end

function I = trap(x, y)
    n = length(x);
    h = x(2) - x(1);
    
    I = 0;

%   Для каждой пары точек считаем площадь трапеции с основанием x_i, x_i+1
%   и вершиной f(x_i), f(x_i+1)
    for i = 1 : n - 1
        I = I + (y(i) + y(i + 1)) * h / 2;
    end
end