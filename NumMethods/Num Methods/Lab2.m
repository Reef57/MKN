%Выводим переменные в глобальную область видимости
global n;
global X_;
global Rmax;
global Rmin;

%12 знаков после запятой
format long e;

%Количество точек рабиения интервала входного
n = 10;
%Гаусс хочет на 1 точку больше
g_n = 11;
%Границы интервала
a = 0.5;
b = 1.0;

%Воспринимать x как символ
syms x
%Задаём свою функцию
f(x) = x^2 - sin(x);
%Считаем от неё производную n + 1 порядка
F(x) = diff(f, n + 1);

%Разбиваем входной интервал на n точек
X = linspace(a, b, n);
%Выделяем память под массив из n значений функции
Y = zeros(1, n);
%Заполняем массив значений функции
for i = 1:n
    Y(i) = f(X(i));
end

%То же самое для Гаусса
X_G = linspace(a, b, g_n);
Y_G = zeros(1, g_n);
for i = 1:g_n
   Y_G(i) = f(X_G(i)); 
end

%То же самое ещёё раз, пригодится в другом месте
X_ = linspace(a, b, n + 1);
Y_ = zeros(1, n + 1);
for i = 1:(n + 1)
    Y_(i) = F(X_(i));
end

%Таблица конечных разностей: первая строчка - значения функции
D = Y
%С помощью встроенной функции diff строим таблицу конечных разностей <: (так можно)
for i = 1:n - 1
  D = diff(D) 
end

%Формируем массив из n + 1 точки нашего интервала, чтобы подать его в
%функцию
xx = linspace(X(1), X(10), n + 1);
%Получаем массив интерполированных значений функции
yy = newton(X, Y, xx);
%Такой же массив по другой формуле
yy_ = newton2(X, Y, xx);
%Точки, которые ближе к концу отрезка точнее интерполировать с помощью
%обратной формулы Ньютона. yy - массив, в котором будет храниться
%окончательный результат интерполяции. Его правую половину перезаписываем
%значениями, посчитанными с помощью обратной формулы Ньютона
yy(n / 2 + 1:end) = yy_(n / 2 + 1:end);

%Среднее значение точнее всего интерполировать с помощью формулы Гаусса.
%Перезапишем это значение в массиве yy
yy(n / 2 + 1) = gauss(xx(n / 2 + 1), X_G, Y_G);

%Рисуем наши исходные узлы символами o и сверху - график, результат
%интерполяции
plot(X, Y, 'o', xx, yy);

%Выделяем память под массив ошибок
R = zeros(1, n + 1);
%Заранее, не в цикле считаем факториал
fact = factorial(n + 1);
%Считаем ошибку по формуле
for i = 1:(n + 1)
   R(i) = abs((Y_(i)/fact) * omega(i));
end

%Находим максимальную/минимальную ошибку
Rmax = max(R);
Rmin = min(R);

%Смотрим, какая интерполяция самая точная в данной точке
checker(0.52,...
    newton(X, Y, 0.52),...
    newton2(X, Y, 0.52),...
    gauss(0.52, X_G, Y_G),...
    reverse_gauss(0.52, X_G, Y_G));

checker(0.97,...
    newton(X, Y, 0.97),...
    newton2(X, Y, 0.97),...
    gauss(0.97, X_G, Y_G),...
    reverse_gauss(0.97, X_G, Y_G));

checker(0.73,...
    newton(X, Y, 0.73),...
    newton2(X, Y, 0.73),...
    gauss(0.73, X_G, Y_G),...
    reverse_gauss(0.73, X_G, Y_G));

function yy = newton(x, y, xx)
%Считаем количество точек входного интервала
    N = length(x);

%Конечная разность нулевого порядка - значение функции
    DIFF = y;

%Считаем конечные разности
    for  k = 1 : N - 1
      for i = 1: N - k
         DIFF(i) = (DIFF(i+1) - DIFF(i)) / (x(i+k) - x(i));
      end
    end

%Инициализируем массив yy конечными разностями
    yy = DIFF(1) * ones(size(xx));
%Заполняем массив yy по формуле с помощью конечных разностей !+ порядка
    for k = 2 : N
        yy = DIFF(k) + (xx - x(k)) .* yy;
    end
end

function yy = newton2(x, y, xx)
%Переворачиваем массив x задом наперёд
    x  =  x(end:-1:1);
%Переворачиваем массив y задом наперёд
    y  =  y(end:-1:1);
%Переворачиваем массив точек, в которых мы интерполируем, задом наперёд
    xx = xx(end:-1:1);
    
%Для перевёрнутых задом наперёд массивов интерполируем по обычной формуле
    yy = newton(x, y, xx);
%Переворачиваем результат задом наперёд
    yy = yy(end:-1:1);
end

%Вспомогательная функция для подсчёта теоретической ошибки
function om = omega(x)
%Используем глобальные переменные
    global n;
    global X_;

%Начальное значение = 1
    om = 1;

%Строим многочлен, т.к. x - символ, а не число
    for i = 1:(n + 0)
        om = om * (x - X_(i));
    end
end

function y = gauss(x, X, Y)
%Считаем шаг сетки
    h = X(2) - X(1);
%Считаем количество пар точек во входном интервале
    n = fix(length(X) / 2);
    
    u = n + 1;
%Выделяем память под матрицу конечных разностей, инициализируем нулями
    DF = zeros(2 * n + 1, 2 * n + 1);
%Конечная разность нулевого порядка - значение функции
    DF(1, 1:end) = Y;
%Заполняем таблицу конечных разностей
    for i = 2:(2 * n + 1)
       DF(i, 1:(end - (i - 1))) = diff(DF(i - 1, 1:(end - (i - 2))));
    end
    
%Считать t символом, а не числом
    syms t
%Создаём многочлен P(t)
    P(t) = 0 * t;
%Просто применение формулы Гаусса. Из-за того, что там чередуются индексы,
%она выглядит крупной
    for i = 1:(n + 1)
        %Блок отвечает за формирование множителя q
       if i == 1
          q = 1;
       else
          q = t;
          if i > 2
             l = 1;
             for j = 3:i
                if rem(j, 2) == 0
                   q = q * (t + l);
                   l = l + 1;
                else 
                   q = q * (t - l);
                end
             end
          end
       end
       %В итоге он будет выглядеть примерно так: q = t(t+1)(t-1)(t+2)(t-2)...
       P(t) = P(t) + (DF(i, u) * q) / factorial(i - 1);
       if rem(i, 2) == 0
          u = u - 1;
       end
    end
    
    q = (x - X(n + 1)) / h;
%Вместо символов подставить числа
    y = double(P(q));
end

function y = reverse_gauss(x, X, Y)
    h = X(2) - X(1);
    n = fix(length(X) / 2);
    u = n + 1;
    
    DF = zeros(2 * n + 1, 2 * n + 1);
    DF(1, 1:end) = Y;
    for i = 2:(2 * n + 1)
       DF(i, 1:(end - (i - 1))) = diff(DF(i - 1, 1:(end - (i - 2))));
    end
    
    syms t;
    P(t) = 0 * t;
%То же самое, что и метод Гаусса. Различается только формирование q
    for i = 1:(n + 1)
        if i == 1
            q = 1;
        else
            q = t;
            l = 0;
            if i > 2
                for j = 3:i
                    if rem(j, 2) == 1
                        l = l + 1;
                        q = q * (t - l);
                    else
                        q = q * (t + l);
                    end
                end
            end
        end
        P(t) = P(t) + (DF(i, u) * q) / factorial(i - 1);
        if rem(i, 2) == 1
            u = u - 1;
        end
    end
    
    q = (x - X(n + 1)) / h;
    y = double(P(q));
end

function checker(point, new, new_r, gau, gau_r)
%Для удобтва закидываем в отдельный массив аргументы функции
    argv = [new, new_r, gau, gau_r];
%Используем глобальные переменные
    global Rmin;
    global Rmax;
    
%x - символ, а не число
    syms x
%Записываем свою функцию
    f(x) = x^2 - sin(x);
%Создаём массив для проверки ответа. 4 ячейки для 4 методов
    good = NaN(1, 4);
    
    for i = 1:4
%Проверяем условие. Если выполнено, то етод попадает в массив good
        if abs(argv(i) - f(point)) > Rmin && abs(argv(i) - f(point)) < Rmax
            good(i) = argv(i);
        end
    end
    
%Считаем, какое значение в массиве good младшее и записываем в переменную best. Имеем право, т.к. там
%хранятся модули абсолютной погрешности
    best = min(good);
%формируем строку-ответ
    str = "В точке " + point + " самая точная интерполяция - с помощью полинома ";
    
%Смотрим, с каким результатом совпадает значение переменной best и
%записываем в строку ответ
    if best == new
        str = str + "Ньютона"
    end
    if best == new_r
        str = str + "Ньютона (обратного)"
    end
    if best == gau
        str = str + "Гаусса"
    end
    if best == gau_r
        str = str + "Гаусса (обратного)"
    end
end